#!/usr/bin/env python

import os
import subprocess
import shutil
import sys

class Print:
  UPDATE = '\033[94m'
  INSTALL = '\033[92m'
  REMOVE = '\033[93m'
  ENDC = '\033[0m'

  INDICATOR = '==> '

  @staticmethod
  def install(message):
    print Print.INSTALL + Print.INDICATOR + Print.ENDC + message

  @staticmethod
  def remove(message):
    print Print.REMOVE + Print.INDICATOR + Print.ENDC + message

  @staticmethod
  def update(message):
    print Print.UPDATE + Print.INDICATOR + Print.ENDC + message

class Config:
  name = ""
  repos_dir = ""
  pager = ""

  def __init__(self, name, repos_dir, pager):
    self.name = name
    self.repos_dir = repos_dir
    self.pater = pager

class Scm:
  name = ""
  clone = ""
  pull = ""
  meta_dir = ""

  def __init__(self, name, clone, pull, meta_dir):
    self.name = name
    self.clone = clone
    self.pull = pull
    self.meta_dir = meta_dir

def _sync_repos(repos, config):
  for repo in repos:
    Print.update('Syncing repo: %s' % repo_dir)
    repo_dir = os.path.join(config.repos_dir(), repo)
    if os.path.isdir(os.path.join(repo_dir, '.git')):
      command = ['git', 'pull']
    elif os.path.isdir(os.path.join(repo_dir, '.svn')):
      command = ['svn', 'up']
    elif os.path.isdir(os.path.join(repo_dir, '.hg')):
      command = ['hg', 'pull', '&&', 'hg', 'update']
    elif os.path.isdir(os.path.join(repo_dir, '.bzr')):
      command = ['bzr', 'update']
    elif os.path.isdir(os.path.join(repo_dir, '_darcs')):
      command = ['darcs', 'pull']
    else:
      print '%s is an invalid repository' % repo
      return os.EX_DATAERR
    proc = subprocess.Popen(command, cwd = repo_dir)
    proc.wait()
    if proc.returncode != 0:
      return proc.returncode
  return 0

def sync_main(argv, config):
  if len(argv) > 0:
    _sync_repos(argv, config)
  else:
    _sync_repos(config.repos_names(), config)
  return 0

def find_main(argv, config):
  if len(argv) == 2:
    find_usage()
    return os.EX_USAGE
  proc = subprocess.Popen(
      ['ls', config.repos_dir, '|', 'grep', argv[2]],
      cwd = config.repos_dir)
  proc.wait()
  return proc.returncode

def ls_main(argv, config):
  proc = subprocess.Popen(['ls', config.repos_dir])
  proc.wait()
  return proc.returncode

def info_main(argv, config):
  repo = argv[2]
  repo_dir = os.path.join(config.repos_dir, repo)
  if not os.path.exists(repo_dir):
    print 'Cannot find repo: %s' % repo
    return os.EX_DATAERR

  proc = subprocess.Popen(
      ['find', '.', '-iname', '"readme*"', '|', 'head', '-n', '1'],
      cwd = repo_dir,
      stdout = subprocess.PIPE,
      stderr = subprocess.PIPE)

  out, err = proc.communicate()
  proc = subprocess.Popen([config.pager, out], cwd = repo_dir)
  proc.wait()
  return proc.returncode

def clone_main(argv, config):
  scm = argv[2]
  repo = argv[3]
  command = {
    'git': ['git', 'clone'],
    'hg':  ['hg', 'clone'],
    'svn': ['svn', 'co'],
    'bzr': ['bzr', 'branch'],
    'darcs': ['darcs', 'get'],
  }.get(sys.argv[0], None)
  if command == None:
    print 'Unsupported SCM %s' % scm
    return os.EX_DATAERR
  Print.update('Cloning repo: %s' % repo)
  command.extend(repo)
  proc = subprocess.Popen(command, cwd = config.repos_dir)
  proc.wait()

def default_main(argv):
  try:
    opts, args = getopt.gnu_getopt(argv, DEFAULT_SHORT_OPTS, DEFAULT_LONG_OPTS)
  except getopt.GetoptError as err:
    print str(err)
    default_usage()
    return os.EX_USAGE

def main():
  repo_configs = {}
  scms = {}
  def repos(name, kwargs):
    repo_configs[name] = Repos(name, kwargs['repos_dir'], kwargs['pager'])

  def scm(name, **kwargs):
    scms[name] = Scm(name, kwargs['clone'], kwargs['pull'], kwargs['meta_dir'])

  

  sys.exit({
    'sync':  sync_main,
    'find':  find_main,
    'ls':    ls_main,
    'info':  info_main,
    'clone': clone_main,
  }.get(sys.argv[0], default_main)(sys.argv))

if __name__ == '__main__':
  main()
